\documentclass{article}
\usepackage{cs170}
\begin{document}

\question{Egg Drop Revisited}

Recall the Egg Drop problem from Homework 5:
\\\\
\textit{You are given $k$ identical eggs and an $n$ story
building. You need to figure out the highest floor
$\ell \in \{0, 1, 2, \ldots n\}$ that you can drop an egg from without
breaking it. Each egg will never break when dropped from floor $\ell$ or lower, and always breaks if dropped from floor $\ell+1$ or higher. ($\ell = 0$ means the egg always breaks). Once an egg breaks, you cannot use it any more. 
\\\\
Let $f(n, k)$ be the minimum number of egg drops that are needed to find $\ell$ (regardless of the value of $\ell$).}
\\\\
Instead of solving for $f(n, k)$ directly, we define a new subproblem $M(d, k)$ to be the maximum number of floors for which we can always find $\ell$ in at most $d$ drops using $k$ eggs.  

\begin{subparts}
\item  Find a recurrence relation for $M(d, k)$ that can be computed in constant time given the previous subproblems. Briefly justify your recurrence.

(Hint: \emph{As a starting point, what is the highest floor that we can drop the first egg from and still be guaranteed to solve the problem with the remaining $d-1$ drops and $k-1$ eggs if the egg breaks?})

\item  Give an algorithm to compute $M(d, k)$ given $d$ and $k$ and analyze its runtime. 

\item  Modify your algorithm from (b) to compute $f(n, k)$ given $n$ and $k$.  (Hint:  \textit{If we can find $\ell$ when there are more than $n$ floors, we can also find $\ell$ when there are $n$ floors.})

\item  Show that the runtime of the algorithm of part (c) is $O(nk)$.  

\item  How can we implement the algorithm using $O(k)$ space?
\end{subparts}

\question{Knightmare}
Give a dynamic programming algorithm to find the number of ways you can place knights on an $N$ by $M$ ($M < N$) chessboard such that no two knights can attack each other (there can be any number of knights on the board, including zero knights). Clearly describe your algorithm and prove its correctness. Your algorithm's runtime can be exponential in $M$ but should be polynomial in $N$. Return your answer mod 1337.

For this problem, write your answer in the following 4-part format:
\begin{subparts}
\item Define a function $f(\cdot)$ in words, including how many parameters are and what they mean, and tell us what inputs you feed into $f$ to get the answer to your problem.
\item Write the ``base cases'' along with a recurrence relation for $f$.
\item Prove that the recurrence correctly solves the problem.
\item Analyze the runtime and space complexity of your final DP algorithm. Can the bottom-up approach to DP improve the space complexity? (For example, we saw in class that Knapsack can be solved in O(nW) space, but one can reduce that to O(W) space via the optimization of only including the last two rows.)
\end{subparts}

\question{Balloon Popping Problem.} You are given a
	sequence of $n$-balloons with each one of a different size. If
	a balloon is popped, then it produces noise equal to $s_{left}
	\cdot s_{popped} \cdot s_{right}$, where $s_{popped}$ is the
	size of the popped balloon and $s_{left}$ and $s_{right}$ are
	the sizes of the balloons to its left and to its right. If
	there are no balloons to the left, then we set $s_{left} = 1$. 
	Similarly, if there are no balloons to the right then we set
	$s_{right} = 1$, while calculating the noise produced.

	After popping a balloon, the balloons to its left and right become neighbors. (Note that the total noise produced depends on the order in which the balloons are popped.)
     
     Design a polynomial-time dynamic programming algorithm to compute the the maximum
     noise that can be generated by popping the balloons. \textit{Hint: Read the section of the textbook on Matrix Chain Multiplication.}\\
 \\
 Example:\\
 Input (Sizes of the balloons in a sequence): \textcircled{4} \textcircled{5}  \textcircled{7} \\
 Output (Total noise produced by the optimal order of popping): 175 

 Walkthrough of the example:
 \begin{itemize}
	 \item \textbf{Current State}  \textcircled{4} \textcircled{5}  \textcircled{7} \\
		 \textit{Pop Balloon \textcircled{5} }\\
		\textbf{Noise Produced  } $ = 4 \cdot 5 \cdot 7$\\

	\item \textbf{Current State}  \textcircled{4}  \textcircled{7} \\
		\textit{Pop Balloon \textcircled{4} }\\
		\textbf{Noise Produced  } $= 1 \cdot 4 \cdot 7$\\


	\item \textbf{Current State}  \textcircled{7}\\
		\textit{Pop Balloon \textcircled{7}}\\
		\textbf{Noise Produced  } $=1 \cdot  7 \cdot 1$\\
	
	\item \textbf{Total Noise Produced}  $= 4\cdot 5\cdot 7 + 1\cdot 4\cdot 7 + 1\cdot 7 \cdot 1.$

 \end{itemize}
 
\begin{subparts}
   \subpart Define your subproblem.
   \subpart What are the base cases?
   \subpart Write down the recurrence relation for your subproblems. What is the runtime of a dynamic programming algorithm using this subproblem?
   %\subpart Write down your pseudocode.
   \end{subparts}

\question{Paper Cutting} There is a piece of paper consisting of an $m \times n$ rectangular grid
of squares.  Some of the squares have holes in them, and you cannot use paper with a hole in it.
You would like to {\it cut} the paper into pieces so as to
separate all the squares with holes from all the intact squares.

For example, shown below is a $6 \times 4$ piece of paper with holes in
squares marked *.  As shown in the picture, one can separate the holes out in
exactly four {\it cuts}.

\begin{tabular}{ccc}
%
\begin{tabular}{|c|c|c|c|c|}
\hline
*  & * &  & *   \\ \hline
  &  &  & *   \\ \hline
 &  &  &  *  \\ \hline
  &  &  & *   \\ \hline
  &  & * & *   \\ \hline
  &  & * & *   \\ \hline
\end{tabular}
%
 $\Longrightarrow$
%
\begin{tabular}{|c|c|}
\hline
 * &  *     \\ \hline
  &      \\ \hline
 &     \\ \hline
  &      \\ \hline
  &     \\ \hline
  &      \\ \hline
\end{tabular}

\begin{tabular}{|c|c|}
\hline
    & *   \\ \hline
    & *   \\ \hline
    & *   \\ \hline
    &  *  \\ \hline
   * & *   \\ \hline
   * &  *  \\ \hline
\end{tabular}
%
 $\Longrightarrow$
%
 \begin{tabular}{c}
 \begin{tabular}{|c|c|}
\hline
 * &  *     \\ \hline
\end{tabular} \\ \\
 \begin{tabular}{|c|c|}
\hline
\hspace{1.8ex} & \hspace{1.8ex}     \\ \hline
 &     \\ \hline
  &      \\ \hline
  &     \\ \hline
  &      \\ \hline
\end{tabular}
\end{tabular}
%
\begin{tabular}{|c|c|}
\hline
    & *   \\ \hline
    & *   \\ \hline
    & *   \\ \hline
    & *   \\ \hline
   * & *   \\ \hline
   * &  *  \\ \hline
\end{tabular}
%
%
 $\Longrightarrow$
%
 \begin{tabular}{c}
 \begin{tabular}{|c|c|}
\hline
 * &  *     \\ \hline
\end{tabular} \\ \\
 \begin{tabular}{|c|c|}
\hline
\hspace{1.8ex} & \hspace{1.8ex}     \\ \hline
 &     \\ \hline
  &      \\ \hline
  &     \\ \hline
  &      \\ \hline
\end{tabular}
\end{tabular}
%
\begin{tabular}{|c|}
\hline
       \\ \hline
        \\ \hline
        \\ \hline
        \\ \hline
   *    \\ \hline
   *    \\ \hline
\end{tabular}
%
\begin{tabular}{|c|}
\hline
    *   \\ \hline
    *   \\ \hline
    *   \\ \hline
    *   \\ \hline
    *   \\ \hline
    *  \\ \hline
\end{tabular} \\ \\
 $\Longrightarrow$
%
 \begin{tabular}{c}
 \begin{tabular}{|c|c|}
\hline
 * &  *     \\ \hline
\end{tabular} \\ \\
 \begin{tabular}{|c|c|}
\hline
\hspace{1.8ex} & \hspace{1.8ex}     \\ \hline
 &     \\ \hline
  &      \\ \hline
  &     \\ \hline
  &      \\ \hline
\end{tabular}
\end{tabular}
%
\begin{tabular}{c}
    \begin{tabular}{|c|}
            \hline
    \hspace{1.8ex}  \\ \hline
             \\ \hline
          \\ \hline
         \\ \hline
    \end{tabular} \\ \\
    \begin{tabular}{|c|}
    \hline
    *    \\ \hline
      *    \\ \hline
     \end{tabular}
\end{tabular}
%
\begin{tabular}{|c|}
\hline
    *   \\ \hline
    *   \\ \hline
    *   \\ \hline
    *   \\ \hline
    *   \\ \hline
    *  \\ \hline
\end{tabular}
%
%
\end{tabular}

(Each {\it cut} is either horizontal or vertical, and of
one piece of paper at a time.)

Design a DP based algorithm to find the smallest number of cuts needed to separate all the holes out.
%
Formally, the problem is as follows:

\textbf{Input:}  Dimensions of the paper $m \times n$ and an
array $A[i,j]$ such that $A[i,j] = 1$ if and only if the $ij^{th}$
square has a hole.

\textbf{Goal:}  Find the minimum number of cuts needed to separate
the holes out.

\begin{subparts}
    \subpart Define your subproblem.



    \subpart Write down the recurrence relation for your subproblems.

\subpart What is the time complexity of solving the above mentioned recurrence? Provide a justification.
\end{subparts}
\end{document}